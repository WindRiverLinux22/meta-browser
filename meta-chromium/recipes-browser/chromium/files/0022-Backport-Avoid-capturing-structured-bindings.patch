From 0d30966b0d9e64003b7e7d5b20ac167ef1060ba2 Mon Sep 17 00:00:00 2001
From: Max Ihlenfeldt <max@igalia.com>
Date: Tue, 30 May 2023 15:56:51 +0000
Subject: [PATCH] Backport "Avoid capturing structured bindings"

This is a backport of https://crrev.com/c/4526976, which refactors some
code to avoid capturing structured bindings in lambdas. This is a C++20
feature and leads to compile errors when using older versions of clang.

Upstream-Status: Backport [https://crrev.com/c/4526976]
Signed-off-by: Max Ihlenfeldt <max@igalia.com>
---
 .../ng/grid/ng_grid_layout_algorithm.cc       | 64 +++++++++----------
 1 file changed, 32 insertions(+), 32 deletions(-)

diff --git a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
index 640c8638f4d0a..38034562eaa61 100644
--- a/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/ng/grid/ng_grid_layout_algorithm.cc
@@ -516,13 +516,12 @@ wtf_size_t NGGridLayoutAlgorithm::BuildGridSizingSubtree(
                                 row_auto_repetitions);
 
   bool has_nested_subgrid = false;
-  auto& [grid_items, layout_data, subtree_size] =
-      sizing_tree->CreateSizingData();
+  auto& sizing_data = sizing_tree->CreateSizingData();
 
   if (!must_ignore_children) {
     // Construct grid items that are not subgridded.
-    grid_items = node.ConstructGridItems(placement_data, oof_children,
-                                         &has_nested_subgrid);
+    sizing_data.grid_items = node.ConstructGridItems(
+        placement_data, oof_children, &has_nested_subgrid);
 
     placement_data.column_start_offset =
         node.CachedPlacementData().column_start_offset;
@@ -534,7 +533,7 @@ wtf_size_t NGGridLayoutAlgorithm::BuildGridSizingSubtree(
     NGGridRangeBuilder range_builder(style, placement_data, track_direction);
 
     bool must_create_baselines = false;
-    for (auto& grid_item : grid_items) {
+    for (auto& grid_item : sizing_data.grid_items) {
       must_create_baselines |=
           grid_item.IsBaselineSpecifiedForDirection(track_direction);
 
@@ -544,7 +543,7 @@ wtf_size_t NGGridLayoutAlgorithm::BuildGridSizingSubtree(
                                         &range_indices.begin,
                                         &range_indices.end);
     }
-    layout_data.SetTrackCollection(
+    sizing_data.layout_data.SetTrackCollection(
         std::make_unique<NGGridSizingTrackCollection>(
             range_builder.FinalizeRanges(), must_create_baselines,
             track_direction));
@@ -561,21 +560,21 @@ wtf_size_t NGGridLayoutAlgorithm::BuildGridSizingSubtree(
     BuildSizingCollection(kForRows);
 
   if (!has_nested_subgrid)
-    return subtree_size;
+    return sizing_data.subtree_size;
 
-  InitializeTrackCollection(opt_subgrid_data, kForColumns, &layout_data);
-  InitializeTrackCollection(opt_subgrid_data, kForRows, &layout_data);
+  InitializeTrackCollection(opt_subgrid_data, kForColumns, &sizing_data.layout_data);
+  InitializeTrackCollection(opt_subgrid_data, kForRows, &sizing_data.layout_data);
 
   if (must_build_sizing_column_collection) {
-    layout_data.SizingCollection(kForColumns).CacheDefiniteSetsGeometry();
+    sizing_data.layout_data.SizingCollection(kForColumns).CacheDefiniteSetsGeometry();
   }
   if (must_build_sizing_row_collection) {
-    layout_data.SizingCollection(kForRows).CacheDefiniteSetsGeometry();
+    sizing_data.layout_data.SizingCollection(kForRows).CacheDefiniteSetsGeometry();
   }
 
   // |AppendSubgriddedItems| rely on the cached placement data of a subgrid to
   // construct its grid items, so we need to build their subtrees beforehand.
-  for (auto& grid_item : grid_items) {
+  for (auto& grid_item : sizing_data.grid_items) {
     if (!grid_item.IsSubgrid())
       continue;
 
@@ -583,17 +582,17 @@ wtf_size_t NGGridLayoutAlgorithm::BuildGridSizingSubtree(
     // the set indices of this grid item to determine its available space. This
     // happens because subgridded items are not considered by the range builder
     // since they can't be placed before we recurse into subgrids.
-    grid_item.ComputeSetIndices(layout_data.Columns());
-    grid_item.ComputeSetIndices(layout_data.Rows());
+    grid_item.ComputeSetIndices(sizing_data.layout_data.Columns());
+    grid_item.ComputeSetIndices(sizing_data.layout_data.Rows());
 
-    NGSubgriddedItemData subgrid_data(grid_item, layout_data);
+    NGSubgriddedItemData subgrid_data(grid_item, sizing_data.layout_data);
 
     NGConstraintSpace unused_space;
     NGFragmentGeometry unused_fragment_geometry;
     auto subgrid_algorithm = CreateSubgridLayoutAlgorithm(
         subgrid_data, &unused_space, &unused_fragment_geometry);
 
-    subtree_size += subgrid_algorithm.BuildGridSizingSubtree(
+    sizing_data.subtree_size += subgrid_algorithm.BuildGridSizingSubtree(
         sizing_tree, /* oof_children */ nullptr, subgrid_data,
         &placement_data.line_resolver);
 
@@ -603,7 +602,7 @@ wtf_size_t NGGridLayoutAlgorithm::BuildGridSizingSubtree(
     grid_item.ResetPlacementIndices();
   }
 
-  node.AppendSubgriddedItems(&grid_items);
+  node.AppendSubgriddedItems(&sizing_data.grid_items);
 
   // We need to recreate the track builder collections to ensure track coverage
   // for subgridded items; it would be ideal to have them accounted for already,
@@ -614,7 +613,7 @@ wtf_size_t NGGridLayoutAlgorithm::BuildGridSizingSubtree(
   if (must_build_sizing_row_collection)
     BuildSizingCollection(kForRows);
 
-  return subtree_size;
+  return sizing_data.subtree_size;
 }
 
 NGGridSizingTree NGGridLayoutAlgorithm::BuildGridSizingTree(
@@ -1540,22 +1539,23 @@ void NGGridLayoutAlgorithm::InitializeTrackSizes(
     NGGridSizingTree* sizing_tree) const {
   DCHECK(sizing_tree && current_grid_index < sizing_tree->Size());
 
-  auto& [grid_items, layout_data, subtree_size] =
-      sizing_tree->At(current_grid_index);
+  auto& sizing_data = sizing_tree->At(current_grid_index);
 
   auto InitAndCacheTrackSizes = [&](GridTrackSizingDirection track_direction) {
-    InitializeTrackCollection(opt_subgrid_data, track_direction, &layout_data);
+    InitializeTrackCollection(opt_subgrid_data, track_direction,
+		              &sizing_data.layout_data);
 
-    if (layout_data.HasSubgriddedAxis(track_direction)) {
+    if (sizing_data.layout_data.HasSubgriddedAxis(track_direction)) {
       const auto& track_collection = (track_direction == kForColumns)
-                                         ? layout_data.Columns()
-                                         : layout_data.Rows();
-      for (auto& grid_item : grid_items) {
+                                         ? sizing_data.layout_data.Columns()
+                                         : sizing_data.layout_data.Rows();
+      for (auto& grid_item : sizing_data.grid_items) {
         grid_item.ComputeSetIndices(track_collection);
       }
     } else {
-      auto& track_collection = layout_data.SizingCollection(track_direction);
-      CacheGridItemsProperties(track_collection, &grid_items);
+      auto& track_collection =
+	  sizing_data.layout_data.SizingCollection(track_direction);
+      CacheGridItemsProperties(track_collection, &sizing_data.grid_items);
 
       const bool is_for_columns = track_direction == kForColumns;
       const auto start_border_scrollbar_padding =
@@ -1587,20 +1587,20 @@ void NGGridLayoutAlgorithm::InitializeTrackSizes(
     InitAndCacheTrackSizes(kForRows);
   }
 
-  if (subtree_size == 1) {
+  if (sizing_data.subtree_size == 1) {
     // If we know this subtree doesn't have nested subgrids we can exit early
     // instead of iterating over every grid item looking for them.
     return;
   }
 
   wtf_size_t next_subgrid_index = current_grid_index + 1;
-  for (const auto& grid_item : grid_items) {
+  for (const auto& grid_item : sizing_data.grid_items) {
     if (!grid_item.IsSubgrid()) {
       continue;
     }
 
-    DCHECK_LT(next_subgrid_index, current_grid_index + subtree_size);
-    NGSubgriddedItemData subgrid_data(grid_item, layout_data);
+    DCHECK_LT(next_subgrid_index, current_grid_index + sizing_data.subtree_size);
+    NGSubgriddedItemData subgrid_data(grid_item, sizing_data.layout_data);
 
     NGConstraintSpace unused_space;
     NGFragmentGeometry unused_fragment_geometry;
@@ -1612,7 +1612,7 @@ void NGGridLayoutAlgorithm::InitializeTrackSizes(
 
     next_subgrid_index += sizing_tree->SubtreeSize(next_subgrid_index);
   }
-  DCHECK_EQ(next_subgrid_index, current_grid_index + subtree_size);
+  DCHECK_EQ(next_subgrid_index, current_grid_index + sizing_data.subtree_size);
 }
 
 void NGGridLayoutAlgorithm::InitializeTrackSizes(
